#!/usr/bin/perl -w

# Process a spec file and output c code for parsing of command line
# options and arguments

# Make the html doc with:
# pod2html --noindex --title "OptionsAndArguments" OptionsAndArguments > OptionsAndArguments.html

# Indentation of variable explanations (with e.g. -help)
$indent = "      ";

print "static char *opt_indent = \"$indent\";\n";
print_header();

# Read file
@structlines = ();
$structlines[0] = "OPTTYPE_SWITCH,VARTYPE_int,NULL,NULL,NULL,NULL";
$n=1;
$stop=0;
while ( <> ) {
    if (/^HELPTEXT/) { # Scan text until blank ^END reuse line breaks
	$helptext = "";
	while (<>) {
	    last if (/^END/);
	    chop;
	    $helptext .= $_ ."\\n";
	}
	$structlines[0] = "OPTTYPE_SWITCH,VARTYPE_int,NULL,NULL,NULL,\"$helptext\"";
    }

    if (/^NAME\s+(.*?)\s+$/) { print "#define PRGNAME \"$1\"\n"; }

    if (/^SWITCH|^VALUE|^ARG/) {
	# OPTIONTYPE VARTYPE NAME INITIAL_VALUE
	($opt,$var,$names,$initial) = split(/\s+/,$_,4)
	    or die("Didn't understand this:\n$_");
	chop $initial;
	# Read the lines of text follwing the cmd until blank line
	$text="";
	$break=$indent;
	$stop=1;
	while (<>) {
	    if ($_ =~ /^\s*$/) { $stop=0; last; }
	    chop;
	    $text .= "$break$_"; $break="\\n$indent";
	}
	# defined($text = <>) or die("File ended while scanning option spec");
	# chop $text;
	# $text = $indent . $text;
	$text =~ s/\<br\>/\\n$indent/g;
	@nm = split(/\|/,$names);
	$names = "\|${names}\|";
	$counter = "\&count_$nm[0]";
	# Print variable definitions
	if ($var=~/char\*\*|int\*|double\*/) {
	    # Fixed-size array
	    if ($initial=~/^([0-9]+)\s*$/) {
		print "static int count_$nm[0]=$1;\n";
	    }
	    # Array sized by another variable
	    else {
		$counter = "\&$initial";
	    }
	    print "static $var $nm[0]=NULL;\n";
	}
	else {
	    print "static int count_$nm[0]=0;\n";
	    if ($var=~/char\*/) {
		if ($initial eq "NULL" || $initial eq "") { $initial = "NULL"; }
		else { $initial = "\"$initial\""; }
	    }
	    print "static $var $nm[0] = $initial;\n";
	}
	# Make entries
	$var=~s/\*/S/g;
	$structlines[$n] = "OPTTYPE_$opt,VARTYPE_$var,(void *)\&$nm[0],$counter,\"$names\",\"$text\"";
	++$n;

	last if ($stop);
    }
}

# Version switch
print "#ifndef VERSION\n#define VERSION \"0\"\n#endif\n";
print "static int count_OPTversion=0;\n";
print "static int OPTversion = 0;\n";
$structlines[$n] = "OPTTYPE_SWITCH,VARTYPE_int,(void *)\&OPTversion,(void *)\&count_OPTversion,\"|version|v|\",\"${indent}Prints version number\"";
++$n;

# Help switch
print "static int count_help=0;\n";
print "static int help = 0;\n";
$structlines[$n] = "OPTTYPE_SWITCH,VARTYPE_int,(void *)\&help,(void *)\&count_help,\"|help|h|\",\"${indent}Prints summary of options and arguments\"";
++$n;

$structlines[$n] = "0,0,NULL,NULL,NULL,NULL";
++$n;

# Print variable struct
print "\nstatic OPT_STRUCT opt_struct[$n] = {\n";
for ($i=0; $i<$n; ++$i) {
    print "\t{$structlines[$i]}";
    print ",\n" if ($i<$n-1)
}
print "\n};\n";

print <<'END';

// This is how you call the cmd line parser etc
// int main(int argc, char **argv) {
//     OPT_read_cmdline(opt_struct, argc, argv);
//     if (help) OPT_help(opt_struct);
//     OPT_print_vars(stderr, opt_struct, "# ", 0);
// }
END


print_functions();



sub print_header {
print <<'END';

/* This code is auto-generated by OptionsAndArguments
   The file should be included by the c program (#include filename)
   To read cmd line use

   OPT_read_cmdline(opt_struct, argc, argv);

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define OPTTYPE_SWITCH 1
#define OPTTYPE_VALUE 2
#define OPTTYPE_ARG 3

#define VARTYPE_int 1
#define VARTYPE_double 2
#define VARTYPE_charS 3
#define VARTYPE_intS 4
#define VARTYPE_doubleS 5
#define VARTYPE_charSS 6


typedef struct {
  int opttype;
  int vartype;
  void *pt;
  int  *count;
  char *names;
  char *text;
} OPT_STRUCT;

END
}


sub print_functions {
print <<'END';

/* PRINT AN ERROR MESSAGE AND EXIT */
static void OPT_error(char *msg) {
  if (msg) fprintf(stderr, "OPT_Error: %s\n", msg);
  exit(1);
}

/* Duplicates a string */
static char *OPT_stringdup(const char *s) {
  int l=1+strlen(s);
  char *ret=(char *)malloc(l*sizeof(char));
  strcpy(ret,s);
  return ret;
}

/* Gives one line per variable with values. Lines are preceeded by
   the prefix string (maybe "").
   If verbose !=0 a more descriptive output is obtained (used with
   -help).
*/
static void OPT_print_vars(FILE *fp, OPT_STRUCT *opt, char *prefix, int  verbose) {
  int argi=1;
  int i;
  char *c;

  if (verbose && opt->text) {
      fprintf(fp,"%s\nOptions and arguments:\n\n",opt->text);
  }
  ++opt;
  while (opt->opttype) {
    if (verbose) {
      fprintf(fp,"%s",prefix);
      c = opt->names;
      if (opt->opttype==OPTTYPE_ARG) fprintf(fp,"ARG %d",argi++);
      else { fputc('-',fp); ++c; }
      while (*c) {
	  if (*c=='|' && *(c+1)) fprintf(fp,", -");
	  if (*c!='|') fputc(*c,fp);
	  ++c;
      }
      if (opt->opttype!=OPTTYPE_SWITCH) {
	switch (opt->vartype) {
	case VARTYPE_int: fprintf(fp," (integer)"); break;
        case VARTYPE_double: fprintf(fp," (double)"); break;
        case VARTYPE_charS: fprintf(fp," (string)"); break;
        case VARTYPE_intS: fprintf(fp," (integer array, current size %d)",*opt->count); break;
        case VARTYPE_doubleS: fprintf(fp," (double array, current size %d)",*opt->count); break;
        case VARTYPE_charSS: fprintf(fp," (string array, current size %d)",*opt->count); break;
        }
      }
      fprintf(fp,"\n%s%s\n%s%sValue: ",prefix,opt->text,prefix,opt_indent);
    }
    else {
      fprintf(fp,"%s",prefix);
      c = opt->names+1; while (*c!='|') fputc(*(c++),fp);
      fputc('=',fp);
    }
    if (opt->opttype==OPTTYPE_SWITCH) {
      fprintf(fp,"%s",(*(int *)(opt->pt)?"ON":"OFF"));
    }
    else {
      switch (opt->vartype) {
      case VARTYPE_int:
	fprintf(fp," %d",*(int *)(opt->pt));
	break;
      case VARTYPE_double:
	fprintf(fp," %f",*(double *)(opt->pt));
	break;
      case VARTYPE_charS:
	if (*(char **)(opt->pt)==NULL) fprintf(fp," NULL");
	fprintf(fp," %s",*(char **)(opt->pt));
	break;
      case VARTYPE_intS:
	if (*(int **)(opt->pt)==NULL) fprintf(fp," NULL");
	else for (i=0;i<*opt->count;++i)
	  fprintf(fp," %d", (*(int **)(opt->pt))[i]);
	break;
      case VARTYPE_doubleS:
	if (*(double **)(opt->pt)==NULL) fprintf(fp," NULL");
	else for (i=0;i<*opt->count;++i)
	  fprintf(fp," %f", (*(double **)(opt->pt))[i]);
	break;
      case VARTYPE_charSS:
	if (*(char ***)(opt->pt)==NULL) fprintf(fp," NULL");
	else for (i=0;i<*opt->count;++i)
	  fprintf(fp," %s", (*(char ***)(opt->pt))[i]);
	break;
      }
    }
    fprintf(fp,"\n");
    if (verbose) fprintf(fp,"%s\n",prefix);

    ++opt;
  }
}


static void OPT_help(OPT_STRUCT *opt) {
  OPT_print_vars(stdout, opt, "", 1);
}


/* Read the command line */
static void OPT_read_cmdline(OPT_STRUCT *opt, int argc, char **argv) {
  int argi=1, i, n=0, match;
  OPT_STRUCT *o;
  char argument[100];
  // void *pt;

  while (argi<argc) {
    match=0;
    o=opt+1;
    /* if option, find match */
    if (argv[argi][0]=='-') {
      while ( o->opttype ) {
	// if (o->opttype == OPTTYPE_SWITCH && argv[argi][1]=='n' && argv[argi][2]=='o') l=3;
	// else l=1;
        sprintf(argument,"|%s|",argv[argi]+1);
	if (strstr(o->names,argument)) {
//          fprintf(stderr,"Found option %s =~ %s\n",argv[argi],o->names);
	  ++argi;
	  match=1;
	  break;
	}
	++o;
      }
    }
    else { /* Otherwise it is an argument */
      while ( o->opttype ) {
	if ( o->opttype == OPTTYPE_ARG && *(o->count) == 0 ) {
//          fprintf(stderr,"Found argument %s fits %s\n",argv[argi],o->names);
	  match=1;
	  break;
        }
	++o;
      }
    }
    if (!match) {
      fprintf(stderr,"Didn't understand argument %s\n\n",argv[argi]);
      OPT_print_vars(stderr, opt, "", 1);
      OPT_error("\n");
    }
    /* Now o is pointing to the relevant option and argi is the argument to read */
    if (o->opttype == OPTTYPE_SWITCH) {
      // if (l==3) *(int *)(o->pt) = 0; else
      *(int *)(o->pt) = 1;
      *(o->count) += 1;
    }
    else {
      if (argi>=argc) OPT_error("Running out of arguments");
      if (o->vartype == VARTYPE_intS || o->vartype == VARTYPE_doubleS || o->vartype == VARTYPE_charSS) {
	// n = *(o->count) = atoi(argv[argi]);
	n = *(o->count);
	if (*(void **)(o->pt)) free(*(void **)(o->pt));
	*(void **)(o->pt) = NULL;
	if (n<=0) OPT_error("Array has zero or negative length");
	if (argi+n>argc) OPT_error("Running out of arguments");
      }
      else *(o->count) += 1;
      switch (o->vartype) {
      case VARTYPE_int:
	*(int *)(o->pt) = atoi(argv[argi++]);
	break;
      case VARTYPE_double:
	*(double *)(o->pt) = atof(argv[argi++]);
	break;
      case VARTYPE_charS:
	if (*(char **)(o->pt) && *(o->count)>1 ) free(*(char **)(o->pt));
	*(char **)(o->pt) = OPT_stringdup(argv[argi++]);
	break;
      case VARTYPE_intS:
	*(int **)(o->pt) = (int *)calloc(n,sizeof(int));
	for (i=0;i<n; ++i, ++argi) (*(int **)(o->pt))[i] = atoi(argv[argi]);
	break;
      case VARTYPE_doubleS:
	*(double **)(o->pt) = (double *)calloc(n,sizeof(double));
	for (i=0;i<n; ++i, ++argi) (*(double **)(o->pt))[i] = atof(argv[argi]);
	break;
      case VARTYPE_charSS:
	*(char ***)(o->pt) = (char **)calloc(n,sizeof(char *));
	for (i=0;i<n; ++i, ++argi) (*(char ***)(o->pt))[i] = OPT_stringdup(argv[argi]);
	break;
      }
    }
  }
  if (OPTversion) {
#ifdef PRGNAME
      fprintf(stderr,"%s ",PRGNAME);
#endif
      fprintf(stderr,"Version %s\n",VERSION);
      exit(0);
  }
}

static char **_add_char_(char **argv, int argc, int i, int c) {
  int k;
  // Alloc/re-alloc argv
  if (i==0) {
    if (argc==1) argv=(char **)calloc(100,sizeof(char*));
    else if (argc%100==0) {
      argv=(char **)realloc(argv,(argc+100)*sizeof(char*));
      for (k=0; k<100; ++k) argv[argc+k]=NULL;
    }
    argv[argc] = (char *)malloc(1001*sizeof(char));
  }
  // realloc individual arg if longer than allocation
  else if (i%1000) argv[argc] = (char *)realloc(argv[argc],(i+1001)*sizeof(char));

  // Argument ends if c==0
  if (!c) {
    argv[argc][i]='\0';
    argv[argc] = (char *)realloc(argv[argc],(i+1)*sizeof(char));
  }
  
  argv[argc][i]=c;
  // argv[argc][i+1]=0; fprintf(stderr,"ARG %d (%d) %s\n",argc,i,argv[argc]);
  return argv;
}

/* Read option file
   All lines must start with
     - '#' a comment line
     - An option (no '-' in front)
     - a blank char, which means the line contains an argument (or is empty)
   Things between "" are read together
*/

static void OPT_read_option_file(FILE *fp, OPT_STRUCT *opt) {
  int i=0, argc=1, quote=0, comment=0, newline=1, c;
  char **argv=NULL;

  while ( (c=fgetc(fp)) != EOF ) {
    // Finish argument
    if ( ( isspace(c) || c=='#') && !quote && !comment && i>0 ) {
      argv = _add_char_(argv,argc,i,0);
      // fprintf(stderr,"--------arg %d >%s<\n",argc,argv[argc]);
      ++argc;
      i=0;
    }

    // At new line a comment ends
    if (c=='\n') { newline=1; comment=0; continue; }
    if (c=='#') { comment=1; }
    if (comment) { continue; }

    if ( isspace(c) && !quote ) continue;

    // If previous was a new line an option name may follow
    if (newline && !isblank(c) ) { argv = _add_char_(argv,argc,i++,'-'); }
    newline=0;

    if ( c=='\'' || c=='\"' ) {
      if (!quote) quote=c;
      else if (c==quote) quote=0;
      continue;
    }

    argv = _add_char_(argv,argc,i++,c);

  }

  if (i>0) {
    argv = _add_char_(argv,argc,i,0);
    // fprintf(stderr,"--------arg %d >%s<\n",argc,argv[argc]);
    ++argc;
  }
 
  OPT_read_cmdline(opt, argc, argv);

  for (i=0; i<argc; ++i) free(argv[i]);
  if (argv) free(argv);
  
}


static inline void OPT_open_read_option_file(char *file, OPT_STRUCT *opt) {
  FILE *fp = fopen(file,"r");
  if (!fp) { fprintf(stderr,"Could not open file %s ",file); OPT_error("\n"); }
  OPT_read_option_file(fp, opt);
  fclose(fp);
}

END
}



=pod

=head1 OptionsAndArguments

Usage:
          OptionsAndArguments specification_file

Reads option specifications and outputs c-code for option parsing in
the form of a header file that is included in the main program.

Format for each specification in file contains two or more lines:

OPTIONTYPE VARTYPE NAME INITIAL_VALUE
EXPLANATION

OPTIONTYPE is one of "SWITCH", "VALUE" or "ARG"

VARTYPE is one of "int", "double", "char*", "int*", "double*", "char**"

NAME is a word, which is the variable name AND the option name. You can
add aliases (alternative names for the option) with an "|" and no
spaces. E.g., "test|t" means that both -test and -t can be used to
set the variable called test.

INITIAL_VALUE is the initial value assigend to a variable. The whole remaining
line is used excluding the final newline for the initial value (e.g. a string
with blanks).

For arrays INITIAL_VALUE is either:
1) the fixed size of the array or 2) the name of the int
variable with the size of the array, which must be set prior to reading
the array. The initial value of the array is always NULL. Example of an
int array of size 3 and a string array of size determined by wnum:

  VALUE int* intArray|i 3
  VALUE int wnum 2
  VALUE char** words|w wnum

On the command line you can now do e.g. '-i 7 9 13 -wnum 3 -w w1 w2 w3'.

The initial value must be written exactly as one would in c. For instance
a char* can be
initialized with This is\nthe\tinitial string for var xx, which results
in a c initialization: int *xx = "This is\nthe\tinitial string for var xx";
(so the sourounding "s are added if it is a char).

To initialize a char* to NULL, leave the space empty or write NULL.

EXPLANATION is text describing the variable (used with eg -help).
Line breaks are re-used. Note that linebreaks can also be put in with
<br> with no spaces around. Ends at first blank line.

You can also specify a general help text printed first with e.g. -h.
This is text between "HELPTEXT" and "END", both in beginning of
line. Like this:
HELPTEXT
 This is
   help text
END
Formatting will be kept.

There is always an option "-help" (or "-h") which results in printing
of all options and arguments with current values and explanations

Whenever a line starting with one of the OPTIONTYPE's is met, a new option
is assumed, and at least one more line (EXPLANATION) must be present.
All other lines are ignored

=cut

