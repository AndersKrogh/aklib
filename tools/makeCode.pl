#!/usr/bin/perl -w

$movein="  ";

#$max_number_backups = 3;      # The maximum number of backups
#$backupdir = "backup_makeCode";

=pod
=head1 Generating C code

The scripts reads a C file and expand recipees to structures and corresponding
alloc_ and free_ functions, makes a header file, etc.

Usage:
       makeCode.pl [-h -noifdef] [filename]

With no options, the file read and the recipees are expanded and the
entire c file is send to stdout.

With no argument, it reads stdin and expand recipees into C-code and outputs
to stdout. Can be used from within emacs to expand a single section of code

-h: Makes the h file to stdout

-noifdef: Do NOT include initial #ifndef etc in the header file

=head2 Header file

Anything enclosed in

 /**HEADER
 ..
 **/

will be included in the H file verbatum.
To make /* */ comments in H-file, use instead /+ +/.

If it starts with "/**HEADER LAST" or /**HEADER END" it will come
after the function prototypes.

Additionally, function prototypes will be made of all non-static functions
in the C file and printed in H-file.

Structeres expanded from recipies will also be written to the H file
(see below).

=head2 Structure Recipies

A recipe for a struct is encolosed in

 /**STRUCT
 ..
 **/

Instead of "STRUCT" it can be "LOCALSTRUCT", which is a struct not put in
header file.

After "STRUCT" follows the name of the struct and then the arguments
for the constructor (like "/**STRUCT Name int a, char b"). Args are comma
separated.
Then follows lines that either starts with "//" (comments) or indented
member variables of the structure. Here is a small structure

 /**STRUCT Word ->s
   char *s;
   int l;
 **/

which expands to

 typedef struct Word {
   char *s;
   int l;
 } Word;

with alloc_ and free_ functions

 Word *alloc_Word(char *s) {
   Word *r;
   r = (Word *)malloc(sizeof(Word));
   r->s = s;
   r->l = (int)0;
   return r;
 }
 void free_Word(Word *r) {
   if (!r) return;
   free(r);
 }

You can add additional code by prependig it with !!. For instance
"!!#ifdefDEBUG" will add this verbatum in the code


=head 2 Modifying alloc function

You can give modifiers to the variables s of the structure by adding "!!="
on the line of the variable. For instance

 /**STRUCT Word ->s
   char *s; !!= strdup(->s);
   int l; !!= strlen(s);
 **/

Now the initializations in the alloc function become

   r->s = strdup(s);
   r->l = strlen(s);

Note that "->s" refers to the variable in the struct and is expanded to r->s
if there is a non-word character in front. SELF->s is always expanded
correctly.

After the variable section, you can give addtional instructions about the
alloc function, e.g.

 ALLOC STATIC         - means the function is static and not in h file
 ALLOC BEGIN <code>   - puts code before the initalizations
 ALLOC END    <code>  - puts code after the initalizations

=head 2 Modifying free function

You can specify code to free variables in the same way as for alloc,
but using "!!-" instead.

You can also use "FREE BEGIN" and "FREE END" as above.
Additionally you can specify a return element with

 FREE RETURN <code>

=cut




use Getopt::Long;

#$opt_c=0;              # Write C file to stdout
$opt_h=0;              # Write header file
$opt_noifdef = 0;      # Do not include "#ifdef NAME_H" etc in hfile 

GetOptions ("h!","c!","e!",'noifdef!') or die "Did not understand options";

# Arg: Name of c file
if ($opt_h || @ARGV) {
    $cfilenm = shift @ARGV or die "Give name of c file";
    $cfilenm .= ".c" if ($cfilenm !~ /\.c$/);
    # Read entire c file into a list
    open(CFILE,"<$cfilenm");
    @cfile = <CFILE>;
    close(CFILE);
}
else { # Read from stdin
    @cfile = <>;
}

if ($opt_h) { # Make a header file
    $hfilenm = $cfilenm;
    $hfilenm =~ s/\.c$/\.h/;
}

# Backup only of C file
#if ($opt_c) {
#    if ( ! -e $backupdir ) { system("mkdir $backupdir") and die "Could not create directory $backupdir"; }
#    my $backup = "";
#    for (my $k=$max_number_backups-1; $k>0; --$k) {
#	$backup = "$backupdir/$cfilenm.b$k";
#	if ( -e $backup ) {
#	    my $older = "$backupdir/$cfilenm.b" . ($k+1);
#	    system("mv $backup $older");
#	}
#    }
#    $backup = "$backupdir/$cfilenm.b1";
#    system("mv $cfilenm $backup");
#
#    # Open file for new
#    open(CFILE,">$cfilenm");
#}
#else { # Use stdout if -c is not set
#    *CFILE = STDOUT;
#}

# All output to stdout
*CFILE = STDOUT;
*HFILE = STDOUT;

# Output for header
if ($opt_h) {
#    open(HFILE,">$hfilenm");

    print HFILE "// This entire file is autogenerated. Edits will be lost\n";
    if ( ! $opt_noifdef ) {
	my $header_def = $hfilenm;
	$header_def =~ s/\./_/g;
	$header_def = uc($header_def);
	print HFILE "#ifndef $header_def\n#define $header_def\n";
    }
}

my $struct=-1;
my $local_struct = 0;
my $func=-1;
my $head=-1;
my $endhead=0;
my $auto=-1;

$prototypes = "";
$h_text_end = "";
    
for ($i=0; $i<@cfile; ++$i) {

    $_ = $cfile[$i];

    # Skip auto-generated code
    $auto=$i if ( $auto<0 && /^\/\/BEGIN AUTO GENERATED/ );
    if ( $auto>=0 && /^\/\/END AUTO GENERATED/ ) {
	$auto=-1;
	next;
    }
    next if ( $auto>=0 );

    # Everything else is put in C file
    print CFILE if (!$opt_h);

    # Find functions and create prototypes
    # Beginning of a funtion
    $func=$i if ( $func<0 && $struct<0 && $head<0 && isFunc($_) );
    # Function spec ends with '{' or blank line
    if ( $func>=0 ) {
	if (/^\s*$/ ) { $func = -1; }
	if (/\{\s*$/ ) {
	    $prototypes .= function_prototype(@cfile[$func .. ($i)]);
	    $func=-1;
	}
    }

    # Header file stuff comes between "^/**HEADER and "^**/"
    # Anything after HEADER will appear as a comment, except LAST or END
    # Other header comments are either single line "//" comments or
    # surrounded by "/+" and "+/"
    if (/^\/\*\*HEADER/) {
	$head=$i;
	$endhead = 1 if (/^\/\*\*HEADER\s*(END|LAST)/);
    }
    if ($head>=0 && /^\*\*\//) {
	if ($opt_h) {
	    if ($endhead) {
		$h_text_end .= "\n" . join_hfile_lines(@cfile[$head .. ($i-1)]);
	    }
	    else {
		print HFILE "\n" . join_hfile_lines(@cfile[$head .. ($i-1)]);
	    }
	}
	$head=-1;
	$endhead=0;
    }	

    # Struct recipees
    $struct=$i if ($struct<0 && /^\/\**STRUCT/);
    if (/^\/\**LOCALSTRUCT/) {
	$struct=$i;
	$local_struct=1;
    }

    if ( $struct>=0 && $cfile[$i] =~/^\*\*\//) {
	@code = expand_recipe(@cfile[$struct .. $i]);
	# The first two items are struct defs and connected prototypes that go
        # into HFILE unless $local_struct
	print CFILE "//BEGIN AUTO GENERATED\n" if (!$opt_h);
	my $structure = shift(@code);
	my $proto = shift(@code);
	if ($local_struct) { print CFILE "\n$structure" if (!$opt_h); }
	else {
	    print HFILE "\n$structure" if ($opt_h);
	    $prototypes = $prototypes . $proto;
	}
	if (!$opt_h) {
	    print CFILE join("",@code);
	    print CFILE "//END AUTO GENERATED\n";
	}
	$struct=-1;
	$local_struct=0;
    }
}

if ($opt_h) {
    print HFILE "\n//Function prototypes\n$prototypes\n";
    print HFILE "\n$h_text_end\n\n" if ($h_text_end);
    print HFILE "#endif\n" if ( ! $opt_noifdef );
    close(HFILE);
}

#close(CFILE) if ($opt_c);








# Returns 1 if it looks like the start of a function
sub isFunc {
    my $r=0;
    $r=1 if ( $_[0] =~ /^\w+\s.*\(/ && $_[0] !~ /^static|^if/ );
    return $r;
}


# This function returns a function prototype as one string (with possible
# new lines)
sub function_prototype {
    my $r = join("",@_);
    if ( $r =~ /\{\s*$/s ) { $r =~ s/\s*\{\s*$/;\n/; }
    else { $r=""; }
    return $r;
}

sub join_hfile_lines {
    $_[0] = ""; # The /**HEADER is removed
    my $r = join("",@_);
    $r =~ s/\/\+/\/\*/g;
    $r =~ s/\+\//\*\//g;
    return $r;
}



sub expand_recipe {
    my $struct_def = "";
    my $flags="";
    my $movein2=$movein.$movein;

    # First line with name and constructor arguments
    my $x = shift @_;
    if ( $x =~ /^\/\*\*\S+\s+(\S+)\s*(.*?)\s*$/) {
	$struct_name = $1;
	$constructor_args = $2;
    }
    else { die "did not understand:\n$x"; }

    $struct_def .= "typedef struct $struct_name {\n";

    %code = (
	FREE => {
	    defined => 1,
	    static => "",
	    type => "void",
	    stars => "",
	    name => "free_$struct_name",
	    args => "($struct_name *r)",
	    defs => "",
	    begin => "${movein}if (!r) returnRETURNVALUE;\n",
	    bulk => "",
	    end => "",
	    "return" => "",
	    final => ""
	},
	ALLOC => {
	    defined => 1,
	    static => "",
	    type => "$struct_name",
	    stars => "*",
	    name => "alloc_$struct_name",
	    args => "()",
	    defs => "${movein}$struct_name *r;\n",
	    begin => "",
	    bulk => "",
	    end => "",
	    return => "${movein}return r;\n",
	    final => ""
	},
	PRINT => {
	    defined => 0,
	    static => "",
	    type => "void",
	    stars => "",
	    name => "print_$struct_name",
	    args => "($struct_name *r, FILE *fp)",
	    defs => "",
	    begin => "",
	    bulk => "",
	    end => "",
	    return => "",
	    final => ""
	},
	READ => {
	    defined => 0,
	    static => "",
	    type => "$struct_name",
	    stars => "*",
	    name => "read_$struct_name",
	    args => "(char *string)",
	    defs => "${movein}$struct_name *r = ($struct_name *)malloc(sizeof($struct_name));\n",
	    begin => "",
	    bulk => "${movein}sscanf(string,ARGS);\n",
	    end => "",
	    return => "${movein}return r;\n",
	    final => ""
	},
	DUP => {
	    defined => 0,
	    static => "",
	    type => "$struct_name",
	    stars => "*",
	    name => "duplicate_$struct_name",
	    args => "($struct_name *s)",
	    defs => "${movein}$struct_name *r = ($struct_name *)malloc(sizeof($struct_name));\n",
	    begin => "",
	    bulk => "${movein}memcpy((void*)r,(void*)s,sizeof($struct_name));\n",
	    end => "",
	    return => "${movein}return r;\n",
	    final => ""
	},
    );

    
    my $ivar=0;
    # The following indented lines are struct elements
    while ( $line=shift @_ ) {
	# Ends with blank line, or non-indented line, which is NOT a // comment
	if ( $line =~ /^\s*\/\//) { next; } # Comment
	elsif ( $line !~ /^\s/ || $line =~ /^\s*$/) { last; }

	# Copy unmodified C source to the struct if it starts with "!!"
	if ( $line =~ /^\s+!!(.+)\s*$/) {
	    $struct_def .= "$1\n";
	    next;
	}

	chop $line;

	# Extract comment (first occurrence of //)
	my $comment="";
	($line,$comment) = split(/\/\//,$line);

	if ( $line =~ /^\s+FLAGS\s+(.+?);/ ) {
	    $flags = "\n// Macroes for flags: $1\n";
	    $flags .= interpret_flags($struct_name,$1);
	    $flags .= "\n";
	    $line= "  unsigned char flag;";
	}
	# the specification of a struct element ends with first ";"
	# Note that pointer '*' can be both at var name and type ("int *x" or "int* x")
	if ( $line =~ /^\s+(.+?)([*\s]+)(\S+);\s*(.*)\s*$/ ) {
	    $var=$3;
	    $varlist[$ivar++] = $var;
	    $type{$var} = $1;
	    $type{$var} = "struct ". $type{$var} if ($type{$var} eq $struct_name);
	    $line=$4;
	    # Pointer stars
	    $ptr{$var} = $2;
	    $ptr{$var} =~ s/\s//g;
	    $struct_def .= "${movein}$type{$var} $ptr{$var}$var;";
	}
	else { die "did not understand: $line"; }

	$struct_def .= " // $comment" if ($comment);
	$struct_def .= "\n";

	$init_var{$var} = "($type{$var})0";
	$init_var{$var} = "NULL" if ($ptr{$var});

	# Check if this var is one of the arguments
	my $n = ( $constructor_args =~ s/\-\>$var/$type{$var} $ptr{$var}$var/ );
	$init_var{$var} = $var if ($n);

	# Initialization code starts with "!!=" and freing code with "!!-"
	# (random order)

	if ($ptr{$var}) {
	    if ($line=~/\!\!\-\s*(.+)$/) {
		my $f=$1;
		$f =~ s/\s*\!\!.*|\s*$//;
		$code{FREE}{bulk} .= "${movein}if (r->$var) ";
		if ($f =~ /WARN/) {
		    $code{FREE}{bulk} .= "fprintf(stderr,\"WARNING: freeing struct $struct_name with non-null pointer to $var\\n\");\n";
		}
		elsif($f =~ /FREE/) {
		    $code{FREE}{bulk} .= "free(r->$var);\n";
		}
		else {
		    $code{FREE}{bulk} .= fix_arrow("r",$f) .";\n";
		}
	    }
	}
	if ($line=~/\!\!\=\s*(.+)$/) {
	    my $a=$1;
	    if ($a =~ /([MC])ALLOC\((\S+)\)/) {
		my $num = $2;
		my $stars = '*' x (length($ptr{$var})-1);
		my $a = "calloc($num,";
		$a = "malloc(($num)*" if ($1 eq "M");
		$a = fix_arrow("r",$a);
		$a .= "sizeof($type{$var}$stars))";
		$code{ALLOC}{"bulk"} .= "${movein}r->$var = ($type{$var}$ptr{$var})$a;\n";
	    }
	    elsif ($a!~/NONE/) {
		$a =~ s/\s*\!\!.*|\s*$//;
		$code{ALLOC}{"bulk"} .= "${movein}r->$var = ". fix_arrow("r",$a) .";\n";
	    }
	}
	else {
	    $code{ALLOC}{"bulk"} .= "${movein}r->$var = $init_var{$var};\n";
	}
    }

    $code{ALLOC}{args} = "($constructor_args)";
    $struct_def .= "} $struct_name;\n$flags";

    # Read rest of recipe
    do {
	if ($line=~/^DUP/) { $code{DUP}{defined} = 1; }
	if ($line=~/^READ/ && !$code{READ}{defined} ) {
	    $code{READ}{defined} =1;
	    my $readargs = "";
	    my $readformat = "";
	    if ($line=~/^READ\s+(\".+\"),(.+)\s*$/) {
		$readformat = $1;
		my $zz = $2;
		$zz =~ s/\s+//g;
		my @arg = split(/,/,$zz);
		for my $x (@arg) {
		    if ( $type{$x}=~/char/ && $ptr{$x} ) { $readargs .= ",r->$x"; }
		    else { $readargs .= ",&(r->$x)"; }
		}
	    }
	    else {
		# Default format and args
		for my $x (@varlist) {
		    $readformat .= type2format($type{$x},$ptr{$x});
		    if ( $type{$x}=~/char/ && $ptr{$x}) { $readargs .= ",r->$x"; }
		    else { $readargs .= ",&(r->$x)"; }
		}
		$readformat = "\"$readformat\"";
	    }
	    $readargs = $readformat . $readargs;
	    $code{READ}{bulk} =~ s/ARGS/$readargs/;
	}
	if ($line=~/^PRINT/ && !$code{PRINT}{defined} ) {
	    $code{PRINT}{defined} =1;
	    for my $x (@varlist)  {
		my $f =type2format($type{$x},$ptr{$x});
		if ( $ptr{$x} && $f eq "UNKNOWN" ) {
		    $f = "";
		    my $ltype = $type{$x};
		    $ltype =~ s/\s/_/g;
		    my $pfunc = "print_$ltype";
		    $pfunc .= "_array" if ($type{$x} =~ /int|double|char/);
		    $pfunc .= "2" if (length($ptr{$x})>1);
		    $code{PRINT}{bulk} .= "${movein}$pfunc(s->$x,fp);\n";
		}
		$code{PRINT}{bulk} .= "${movein}fprintf(fp,\"$x: $f\\n\",s->$x);\n" if ($f);
	    }
	}

	# Return a struct member with or without "->"
	if ($line=~/^FREE\s+RETURN\s+(.+?)\s*$/) {
	    my $v=$1;
	    $v=~s/;$//;
	    $v=~s/^-\>//;
	    $code{FREE}{type} = $type{$v};
	    $code{FREE}{stars} = $ptr{$v};
	    my $x = "($code{FREE}{type})0";
	    $x = "NULL" if ($code{FREE}{stars});
	    $code{FREE}{defs} = "$movein$type{$v} $ptr{$v}_ret_ = $x;\n";
	    $code{FREE}{begin} =~ s/RETURNVALUE/ _ret_/;
	    $code{FREE}{begin} .= "${movein}_ret_ = r->$v;\n";	
	    $code{FREE}{return} = "${movein}return _ret_;\n";

	}
	elsif ( $line =~ /^(FREE|ALLOC|PRINT|READ|DUP)\s+NONE\s*$/ ) {$code{$1}{defined} = 0;}
	elsif ( $line =~ /^(FREE|ALLOC|PRINT|READ|DUP)\s+NAME\s+(.+?)\s*$/ ) {$code{$1}{name} = $2;}
	elsif ( $line =~ /^(FREE|ALLOC|PRINT|READ|DUP)\s+STATIC/) {$code{$1}{"static"} = "static ";}
	elsif ( $line =~ /^(FREE|ALLOC|PRINT|READ|DUP)\s+HEADER/ ) {$code{$1}{defined} = 2; $code{$1}{"static"} = "static ";}
	elsif ( $line =~ /^(FREE|ALLOC|PRINT|READ|DUP)\s+INLINE/ ) {$code{$1}{"static"} = "static inline ";}
	elsif ( $line =~ /^(FREE|ALLOC|PRINT|READ|DUP)\s+(BEGIN|END)\s+(.+?)\s*$/ ) {
	    my $a1 = $1;
	    my $a2 = lc($2);  # BEGIN/END changed to lower case
	    my $a3 = $3;
	    $a3 = "${movein}$a3" if ($a3!~/^\#/);
	    $a3 = fix_arrow("r",$a3) ."\n";
	    $code{$a1}{$a2} .= $a3;
	}
    } while ( $line=shift @_ );

    if (!$code{ALLOC}{begin}) {
	$code{ALLOC}{begin} = "${movein}r = ($struct_name *)malloc(sizeof($struct_name));\n";
    }
    if (!$code{FREE}{end}) {
	$code{FREE}{end} .= "${movein}free(r);\n";
    }

    # First return statement for an empty struct in free code may need an argument
    $code{FREE}{begin} =~ s/RETURNVALUE//;

    my $prototypes = "";
    for my $x ("FREE","ALLOC","PRINT","READ","DUP") {
	if ($code{$x}{defined}) {
	    $q = "$code{$x}{static}$code{$x}{type} $code{$x}{stars}$code{$x}{name}$code{$x}{args} {\n";
	    $q .= "$code{$x}{defs}$code{$x}{begin}$code{$x}{bulk}$code{$x}{end}$code{$x}{return}}\n";
	    if ($code{$x}{defined}==2) {
		$prototypes .= $q;
	    }
	    else {
		$code{$x}{final} = $q;
		$prototypes .= "$code{$x}{type} $code{$x}{stars}$code{$x}{name}$code{$x}{args};\n" if (!$code{$x}{static});
	    }
	}
    }
    
    return ( $struct_def, $prototypes, $code{ALLOC}{final}, $code{FREE}{final}, $code{DUP}{final}, $code{PRINT}{final}, $code{READ}{final});
}


# A "->" is replaced with "var->" and SELF with var
sub fix_arrow {
    # first arg is var name and second is string
    # \K means that previous is NOT included in subst. \W is a "non-word" char
    $_[1] =~ s/\W\K\-\>/$_[0]->/g;
    $_[1] =~ s/SELF/$_[0]/g;
    return $_[1];
}


# First arg is structure name, remaining are flag names (one string)
sub interpret_flags {
    my $flag_funcs = "";
    my $s = shift @_;
    my $n=1;
    my $k=0;
    for my $f ( split(/\s+/,$_[0]) ) {
	my $comp = $n ^ 255;
	$flag_funcs .= "#define ${s}_${f}_toggle(x) (((x)->flag) ^= $n)\n";
	$flag_funcs .= "#define ${s}_${f}_set(x)    (((x)->flag) |= $n)\n";
	$flag_funcs .= "#define ${s}_${f}_clear(x)  (((x)->flag) &= $comp)\n";
	$flag_funcs .= "#define ${s}_${f}_true(x)  (((x)->flag) & $n)\n";
	$n *= 2;
	++$k;
    }
    die "You have $k flags. Max 8 are allowed" if ($k>8);
    return $flag_funcs;
}



sub type2format {
    my $t = shift @_;
    my $ptr = shift @_;
    my $f = "";
    if ($t eq "char" && $ptr eq "*" ) {
	$f = "%s";
    }
    else {
	if ($t =~ /int/) { $f="%d"; }
	elsif ($t =~ /char/) { $f="%c"; }
	elsif ($t =~ /double/) { $f="%lf"; }
	else { $f="UNKNOWN"; }
    }
    return $f;
}
